#===============================================================================
#
# Device Config Builder
#
# GENERAL DESCRIPTION
#    Contains builder(s) definitions
#
# Copyright (c) 2014, 2015 by QUALCOMM, Technologies Inc.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#
#-------------------------------------------------------------------------------
#
#  $Header: //components/rel/core.tz/1.0.3.c1/bsp/build/scripts/devcfg_lcs_builder_llvm.py#1 $
#  $DateTime: 2016/12/02 01:46:26 $
#  $Author: pwbldsvc $
#  $Change: 11896995 $
#                      EDIT HISTORY FOR FILE
#                      
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#  
# when       who     what, where, why
# --------   ---     ---------------------------------------------------------
# 03/04/15   aa    Removed ENTRY attribute, no symbols to set entry point 
# 10/14/14   aa    Initial Revision
#===============================================================================

import os
import subprocess
import string
from SCons.Script import *

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Hooks for Scons
#------------------------------------------------------------------------------
def exists(env):
   return True

def generate(env):
   """
   Generate function for devcfg lcs builder. 
   Generates devcfg linker script
   """

   rootenv = env.get('IMAGE_ENV')
   # Devcfg linker script generator
   devcfg_lcs_act = env.GetBuilderAction(devcfg_lcs_builder, action_source=None)
   devcfg_lcs_target_scan = env.Scanner(devcfg_lcs_target_scan_func, name='DevCfgTargetScanner')
   devcfg_lcs_bld = env.Builder(action = devcfg_lcs_act,
                                target_scanner = devcfg_lcs_target_scan,
                                suffix = '.lcs')
   rootenv.Append(BUILDERS = {'DevcfgLCSBuilder' : devcfg_lcs_bld})

   return
   
def devcfg_lcs_target_scan_func(node, env, path):
   rootenv = env.get('IMAGE_ENV')
   env.Depends(node, env.Value(rootenv.get('DEVCFG_INFO_COLLECTOR', [])))
   return []

   
def devcfg_lcs_builder(target, source, env):
   """
   source: lcs template file name with location
   """
   rootenv = env.get('IMAGE_ENV')
   
   if rootenv.GetUsesFlag('USES_DEVCFG') is False:
      return None
     
   # The output linker script file name
   lcs_fn = env.RealPath(str(target[0]))
   
   create_devcfg_lcs_file(rootenv, lcs_fn)
   
def create_devcfg_lcs_file(env, output_devcfg_lcs_file):
   """
   This creates the output linker script for devcfg image
   INPUTS:
   env: Build environment
   template_file: Template filename that the linker script will be based off of
   devcfg_hdr_filename: The devcfg header file that will contain the addressed
   of the segments. These will be reserved in the primary elf
   OUTPUT:
   output_devcfg_lcs_file: Generated devcfg lcs file   
   """
   #import pdb;pdb.set_trace()
   devcfg_xml_list =  env.get('DEVCFG_INFO_COLLECTOR', [])  
   hyp_source_list = []
   tz_source_list = []
   hyp_source_list2 = []
   tz_source_list2 = []
   for xml_tag in env.get('DEVCFG_XML_TAGS') :
      for dict in  env.get('DEVCFG_INFO_COLLECTOR', []) :
         sub_dict_list = dict.get('cc_' + xml_tag)
         for build_tag in env.get('BUILD_TAGS') :
            if(sub_dict_list):
               for sub_dict in sub_dict_list :
                  source_list = sub_dict.get(build_tag,[])
                  if 'HYP'.lower() in build_tag.lower() :
                     for file in source_list:
                           if file not in hyp_source_list and '.o' in file.path:
                              hyp_source_list.append(file)
                  if 'QSEE'.lower() in build_tag.lower() :
                     for file in source_list :
                        if file not in tz_source_list and '.o' in file.path:
                           tz_source_list.append(file)			  
   try:
      lcsf = open(output_devcfg_lcs_file, 'w')
   except IOError:
      err_str = " Couldn't open file: " + output_devcfg_lcs_file + "for writing\n"
      devcfg_lcs_error(err_str)
   
   template = '''/*===========================================================================
#
# FILE:         devconfig_data.scl
#
# DESCRIPTION:  Linker File for deviceconfig image
#
# AUTOGENERATED, DON NOT MODIFY THIS FILE
===========================================================================*/
#include "customer.h"
\n'''

   lcsf.write(template)
   segement = '''PHDRS {
  DEVCFG_DATA_SEG_TZ PT_LOAD;
  DEVCFG_DATA_SEG_HYP PT_LOAD;
}\n'''
   lcsf.write(segement)
   lcsf.write('SECTIONS {\n')
   #------------------------------------------------------------------------------
   # Linker Rule for QSEE Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_TZ (DEVCFG_DATA_TZ_ADDR):
   {
      KEEP(*\DevCfgSegInfo_tz_oem.o (.rodata* .data* .sdata*)) 
''')
   for tag in env.get('DEVCFG_XML_TAGS'):
      id = str(tag).split("_")[0]
      file_name_ext = id + "_data_tz_oem.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
      file_name_ext = "DALConfig_" + id + "_tz_oem.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for file in tz_source_list:
      file_path = env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_TZ) <= DEVCFG_DATA_TZ_SZ, "Oversize");\n   }:DEVCFG_DATA_SEG_TZ\n''')
   
  
   #------------------------------------------------------------------------------
   # Linker Rule for HYP Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_HYP (DEVCFG_DATA_HYP_ADDR):
   {
      KEEP(*\DevCfgSegInfo_hyp_oem.o (.rodata* .data* .sdata))
''')
   for tag in env.get('DEVCFG_XML_TAGS'):
      id = str(tag).split("_")[0]
      file_name_ext = id + "_data_hyp_oem.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
      file_name_ext = "DALConfig_" + id + "_hyp_oem.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for file in hyp_source_list:
      file_path = env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_HYP) <= DEVCFG_DATA_HYP_SZ, "Oversize");\n     }:DEVCFG_DATA_SEG_HYP\n''')
   
   others = '''\n  .got : { * (.got) }
  .got.plt : { * (.got.plt) }
  .debug 0 : { *(.debug) }
  .line 0 : { *(.line) }

  .debug_srcinfo 0 : { *(.debug_srcinfo) }
  .debug_sfnames 0 : { *(.debug_sfnames) }

  .debug_aranges 0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }

  .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev 0 : { *(.debug_abbrev) }
  .debug_line 0 : { *(.debug_line) }
  .debug_frame 0 : { *(.debug_frame) }
  .debug_str 0 : { *(.debug_str) }
  .debug_loc 0 : { *(.debug_loc) }
  .debug_macinfo 0 : { *(.debug_macinfo) }

  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames 0 : { *(.debug_varnames) }

  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges 0 : { *(.debug_ranges) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
  /DISCARD/ : { *(.ARM.exidx*) *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.init) *(.fini)}\n'''

   lcsf.write(others)
   lcsf.write('''}''')
   lcsf.close()
   
   return
    
def devcfg_lcs_error(Info, Info1=None):
   """
   Error handler for devcfg framework. Info can be a string that describes the error and
   Info1 can be any data that needs to be printed along with the error message.
   """
   print Info
   raise Exception(Info)
   