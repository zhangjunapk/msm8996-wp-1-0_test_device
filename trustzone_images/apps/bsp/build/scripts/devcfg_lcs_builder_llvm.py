#===============================================================================
#
# Device Config Builder
#
# GENERAL DESCRIPTION
#    Contains builder(s) definitions
#
# Copyright (c) 2014, 2015 by QUALCOMM, Technologies Inc.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#
#-------------------------------------------------------------------------------
#
#  $Header: //components/rel/apps.tz/1.0.6/bsp/build/scripts/devcfg_lcs_builder_llvm.py#1 $
#  $DateTime: 2016/12/02 01:50:16 $
#  $Author: pwbldsvc $
#  $Change: 11897059 $
#                      EDIT HISTORY FOR FILE
#                      
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#  
# when       who     what, where, why
# --------   ---     ---------------------------------------------------------
# 03/04/15   aa    Removed ENTRY attribute, no symbols to set entry point 
# 10/14/14   aa    Initial Revision
#===============================================================================

import os
import subprocess
import string
from SCons.Script import *

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Hooks for Scons
#------------------------------------------------------------------------------
def exists(env):
   return True

def generate(env):
   """
   Generate function for devcfg lcs builder. 
   Generates devcfg linker script
   """

   rootenv = env.get('IMAGE_ENV')
   # Devcfg linker script generator
   devcfg_lcs_act = env.GetBuilderAction(devcfg_lcs_builder, action_source=None)
   devcfg_lcs_target_scan = env.Scanner(devcfg_lcs_target_scan_func, name='DevCfgTargetScanner')
   devcfg_lcs_bld = env.Builder(action = devcfg_lcs_act,
                                target_scanner = devcfg_lcs_target_scan,
                                suffix = '.lcs')
   rootenv.Append(BUILDERS = {'DevcfgLCSBuilder' : devcfg_lcs_bld})

   return
   
def devcfg_lcs_target_scan_func(node, env, path):
   rootenv = env.get('IMAGE_ENV')
   env.Depends(node, env.Value(rootenv.get('DEVCFG_INFO_COLLECTOR', [])))
   return []

   
def devcfg_lcs_builder(target, source, env):
   """
   source: lcs template file name with location
   """
   rootenv = env.get('IMAGE_ENV')
   
   if rootenv.GetUsesFlag('USES_DEVCFG') is False:
      return None
     
   # The output linker script file name
   lcs_fn = env.RealPath(str(target[0]))
   
   create_devcfg_lcs_file(rootenv, lcs_fn)
   
def create_devcfg_lcs_file(env, output_devcfg_lcs_file):
   """
   This creates the output linker script for devcfg image
   INPUTS:
   env: Build environment
   template_file: Template filename that the linker script will be based off of
   devcfg_hdr_filename: The devcfg header file that will contain the addressed
   of the segments. These will be reserved in the primary elf
   OUTPUT:
   output_devcfg_lcs_file: Generated devcfg lcs file   
   """
   #import pdb;pdb.set_trace()
   devcfg_xml_list =  env.get('DEVCFG_INFO_COLLECTOR', [])  
   hyp_source_list = []
   tz_source_list = []
   for build_tag in env.get('BUILD_TAGS') :
      for sub_dict in  env.get('DEVCFG_INFO_COLLECTOR', []) :
         sources = sub_dict.get(build_tag+'_C')
         if(sources):
            if 'HYP'.lower() in build_tag.lower() :
               hyp_source_list.extend(sources)
            if 'QSEE'.lower() in build_tag.lower() :
               tz_source_list.extend(sources)
   
   try:
      lcsf = open(output_devcfg_lcs_file, 'w')
   except IOError:
      err_str = " Couldn't open file: " + output_devcfg_lcs_file + "for writing\n"
      devcfg_lcs_error(err_str)
   
   template = '''/*===========================================================================
#
# FILE:         devconfig_data.scl
#
# DESCRIPTION:  Linker File for deviceconfig image
#
# AUTOGENERATED, DON NOT MODIFY THIS FILE
===========================================================================*/
#include "customer.h"
\n'''

   lcsf.write(template)
   segement = '''PHDRS {
  DEVCFG_DATA_SEG_TZ PT_LOAD;
  DEVCFG_DATA_SEG_HYP PT_LOAD;
}\n'''
   lcsf.write(segement)
   lcsf.write('SECTIONS {\n')
   #------------------------------------------------------------------------------
   # Linker Rule for QSEE Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_TZ (DEVCFG_DATA_TZ_ADDR):
   {
      KEEP(*\devcfg_data_tz_oem.o (.rodata* .data* .sdata*))
      KEEP(*\DALConfig_tz_oem.o (.rodata* .data* .sdata*))
''')
   for file in tz_source_list:
      file_path = env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
         
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_TZ) <= DEVCFG_DATA_TZ_SZ, "Oversize");\n   }:DEVCFG_DATA_SEG_TZ\n''')
   
  
   #------------------------------------------------------------------------------
   # Linker Rule for HYP Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_HYP (DEVCFG_DATA_HYP_ADDR):
   {
      KEEP(*\devcfg_data_hyp_oem.o (.rodata* .data* .sdata*))
      KEEP(*\DALConfig_hyp_oem.o (.rodata* .data* .sdata*))
''')
   for file in hyp_source_list:
      file_path = env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_HYP) <= DEVCFG_DATA_HYP_SZ, "Oversize");\n     }:DEVCFG_DATA_SEG_HYP\n''')
   
   others = '''\n  .got : { * (.got) }
  .got.plt : { * (.got.plt) }
  .debug 0 : { *(.debug) }
  .line 0 : { *(.line) }

  .debug_srcinfo 0 : { *(.debug_srcinfo) }
  .debug_sfnames 0 : { *(.debug_sfnames) }

  .debug_aranges 0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }

  .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev 0 : { *(.debug_abbrev) }
  .debug_line 0 : { *(.debug_line) }
  .debug_frame 0 : { *(.debug_frame) }
  .debug_str 0 : { *(.debug_str) }
  .debug_loc 0 : { *(.debug_loc) }
  .debug_macinfo 0 : { *(.debug_macinfo) }

  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames 0 : { *(.debug_varnames) }

  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges 0 : { *(.debug_ranges) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
  /DISCARD/ : { *(.ARM.exidx*) *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.init) *(.fini)}\n'''

   lcsf.write(others)
   lcsf.write('''}''')
   lcsf.close()
   
   return
    
def devcfg_lcs_error(Info, Info1=None):
   """
   Error handler for devcfg framework. Info can be a string that describes the error and
   Info1 can be any data that needs to be printed along with the error message.
   """
   print Info
   raise Exception(Info)
   